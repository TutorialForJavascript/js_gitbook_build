
# 面向对象编程


js与java不同,它是真正的面向对象编程(java是面向类型编程).

其实正经说js的叫做原型编程模型

js的设计者认为对象之间的相似性可以让面向对象的继承得到简化,通过直接复制一个与自己类似的对象,稍作修改就可以实现自己的对象了,真是朴素哇

我们要创建一个新的商品叫莎士比亚全集,那我们直接拿书做原型就行了

如我们前面说了那么多的特殊对象,他们就是原型,使用他们的时候本质上就是用new关键字做一份原型的拷贝对象.


在容器部分我们已经介绍过对象,这边我们从类开始介绍js的面向对象编程.

# 类

从ES6开始关键字`class`可以用于定义类.


```javascript
class Point {

  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }
}
```




    'use strict'




```javascript
typeof Point
```




    'function'




```javascript
Point === Point.prototype.constructor
```




    true




```javascript
let point = new Point(1,2)
```




    'use strict'




```javascript
point
```




    Point { x: 1, y: 2 }




```javascript
point.constructor === Point.prototype.constructor
```




    true



上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。

Point类除了构造方法，还定义了一个toString方法。注意，定义'类'的方法的时候，前面不需要加上function这个保留字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。

上面代码表明，类的数据类型就是函数，类本身就指向构造函数。

构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。

在类的实例上面调用方法，其实就是调用原型上的方法。

由于类的方法（除constructor以外）都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。

类的内部所有定义的方法，都是不可枚举的（enumerable）。

实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。类的所有实例共享一个原型对象

## Class表达式

与函数一样，Class也可以使用表达式的形式定义。



```javascript
const MyClass = class cls{
  getClassName() {
    return cls.name
  }
}
```




    'use strict'



上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是cls，cls只在Class的内部代码可用，指代当前类。


```javascript
let inst = new MyClass();
inst.getClassName() // Me
cls.name // Referen
```


    ReferenceError: Me is not defined

        at evalmachine.<anonymous>:5:1

        at Object.exports.runInThisContext (vm.js:54:17)

        at run ([eval]:192:19)

        at onMessage ([eval]:63:41)

        at emitTwo (events.js:87:13)

        at process.emit (events.js:172:7)

        at handleMessage (internal/child_process.js:686:10)

        at Pipe.channel.onread (internal/child_process.js:440:11)



```javascript
inst.name
```




    undefined



如果Class内部没用到的话，可以省略Me.


```javascript
let person = new class {
  constructor(name) {
    this.name = name;
  }

  sayName() {
    console.log(this.name);
  }
}("张三");

person.sayName(); // "张三"
```

    张三
    




    undefined



上面代码中，person是一个立即执行的Class的实例。

## 封装

ES6允许使用Class的取值函数（getter）和存值函数(setter)对某个属性设置存值函数和取值函数，拦截该属性的存取行为。




```javascript
class MyClass {
  constructor() {
    // ...
  }
  get prop() {
    return 'getter';
  }
  set prop(value) {
    console.log('setter: '+value);
  }
}

```




    'use strict'




```javascript
let inst = new MyClass();

inst.prop = 123;
```

    setter: 123
    




    123




```javascript
inst.prop
```




    'getter'



存值函数和取值函数是设置在属性的descriptor对象上的。

### 静态方法

类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。与python中一样,静态方法无法被实例使用



```javascript
class Foo {
  static classMethod() {
    console.log('hello')
  }
}

Foo.classMethod() // 'hello'

var foo = new Foo();
foo.classMethod()
```

    hello
    


    TypeError: foo.classMethod is not a function

        at evalmachine.<anonymous>:25:5

        at Object.exports.runInThisContext (vm.js:54:17)

        at run ([eval]:192:19)

        at onMessage ([eval]:63:41)

        at emitTwo (events.js:87:13)

        at process.emit (events.js:172:7)

        at handleMessage (internal/child_process.js:686:10)

        at Pipe.channel.onread (internal/child_process.js:440:11)


## 继承

ES6中的继承采用extend关键字实现

```javascript
class B extends A {
}
```

extends关键字后面可以跟多种类型的值。只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性，因此A可以是任意函数


### super()方法

和python一样,js也有super()方法来构造父类实例(相当于python中的`super().__init__(self,*args)`),
ES6的继承机制是这样:

1. 先创造父类的实例对象this（所以必须先调用super方法）
2. 然后再用子类的构造函数修改this


### Object.getPrototypeOf() 
Object.getPrototypeOf方法可以用来从子类上获取父类。


### 类的prototype属性和__proto__属性

大多数浏览器中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。

（1）子类的__proto__属性，表示构造函数的继承，总是指向父类。

（2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。

他们之间的关系可以看这张图:

![js继承](./source/jsextend.png)


### Mixin模式的实现

Mixin模式指的是，将多个类的接口“混入”（mix in）另一个类。它在ES6的实现如下。

```javascript
function copyProperties(target, source) {
  for (let key of Reflect.ownKeys(source)) {
    if ( key !== "constructor"
      && key !== "prototype"
      && key !== "name"
    ) {
      let desc = Object.getOwnPropertyDescriptor(source, key);
      Object.defineProperty(target, key, desc);
    }
  }
}
function mix(...mixins) {
  class Mix {}

  for (let mixin of mixins) {
    copyProperties(Mix, mixin);
    copyProperties(Mix.prototype, mixin.prototype);
  }

  return Mix;
}

class DistributedEdit extends mix(Loggable, Serializable) {
  // ...
}
```
