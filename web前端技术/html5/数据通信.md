# 数据通信

前端项目往往只是作为展现,数据,运算往往要依赖后端服务器,因此与服务器间的通信是非常重要的.在最开始的时候http协议只想做个用于发布和接收HTML页面的协议,它不想搞得太复杂,但随着时代的变迁,越来越多的通信需求让它与服务器间的交互手段越来越多,web的发展是在太快,很少有实现快于标准的技术,而web技术就是一个.html5协议规定了两个新的通信协议,分别是`web messaging`,`EventSource`和`websocket`.

总结html通信技术,在客户端/服务器结构上

+ 从最早的`客户端请求,服务器响应模式`
+ 到`ajax`实现的伪双向通信
+ 到`ajax轮询技术`实现的伪服务器端主动通信
+ 到`EventSource`实现的服务器端主动通信
+ 再到`web socket`实现的双向通信

在对等通信上,

+ 有`web Messaging`实现跨文档通信
+ 有`WebRTC`实现跨客户端p2p通信

本部分代码都需要服务器,不是纯前端技术,不感兴趣的可以直接下一章


## ajax

最常见的服务端通信无疑是`ajax`技术,但ajax有跨域访问问题.所谓跨域,就是服务器"A"上的页面获取服务器"B"上的资源，
这种情况浏览器默认是不允许的.跨域的严格一点的定义是：只要 协议，域名，端口有任何一个的不同，就被当作是跨域.
浏览器会检查服务器B的HTTP头(HEAD请求)，如果`Access-Control-Allow-Origin`中有"A"，或者是通配符`*`，浏览器就会允许跨域,这叫`CORS`.

解决跨域问题,当然可以在服务器端使用反向代理(nginx),把不同的域放到一起,但如果我们要跨的域我们无法这么操作,就会很麻烦.



## EventSource

ajax实现了"伪"服务器端向浏览器主动发送消息,而`EventSource`则是真正实现这一功能的技术,

`EventSource`依然不支持跨域访问(至少chrome不支持),也就是说如果是要多服务架构,也得像之前的ajax一样放在代理之后.

前端方面用`EventSource(URL)`来实例化一个与对应url相连的通道,之后可以使用`onopen`,`onmessage`等来监听事件,当然如果是自定义事件,可以使用`addEventListener`来实现


nodejs上可以使用expresse和express搭配构建

## websocket

`websocket`则是一种相对颠覆协议,它用起来和tcp的套接字类似,可以实现客户端(浏览器)和服务器间的双工通信.

在websocket之前,大家往往使用轮询技术来实现双工通信,轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP request，然后由服务器返回最新的数据给客户端的浏览器。这种传统的`HTTP request` 的模式带来很明显的缺点--浏览器需要不断的向服务器发出请求，然而`HTTP request`的`header`是非常长的，里面包含的有用数据可能只是一个很小的值，这样会占用很多的带宽。

`websocket`的话,浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。在此WebSocket 协议中，为我们实现即时服务带来了两大好处:

1. Header

    互相沟通的Header是很小的-大概只有 2 Bytes

2. Server Push

    服务器的推送，服务器不再被动的接收到浏览器的request之后才返回数据，而是在有新数据时就主动推送给浏览器。

websocket需要服务器端支持,像python中可以使用gevent-websocket,flask-sockets来实现,像node中可以使用ws来实现

客户端的websocket同样有几个事件来绑定回调函数:

+ onopen

    连接成功会执行这个事件

+ onmessage

    接收websocket推送过来的消息

+ onconnecting

    这是个监听事件，当连接开始尝试进行，事件监听器被调用。

+ onclose

    websocket关闭会执行这个事件

以及几个常用方法:

+ send

    通过websocket向后端发送消息。

+ close

    关闭 WebSocket 连接／连接尝试，若连接已为 CLOSED，此方法沒有作用。


而服务器端,根据不同的框架实际上接口并不统一

## socket.io


因为websocket比较新,而且后端实现其实不太统一,于是就有了一种非官方的新协议[socket.io](http://socket.io/)它可以在轮询,websocket间切换,实现统一api下的多种连接方式自动切换,socket.io是目前最流行的websocket实现方法


socket.io整合并添加了许多接口,并且可以方便的做广播或者按房间(分组)来发送消息

下面是服务端可以用到的工具:

[flask-socketio](http://flask-socketio.readthedocs.io/en/latest/)

他的翻译在简书上,分为三篇
+ <http://www.jianshu.com/p/be4b23ea0ba5>
+ <http://www.jianshu.com/p/f4f85539ecbb>
+ <http://www.jianshu.com/p/f53c6dfdc59a>

[koa-socket](https://github.com/mattstyles/koa-socket)


## messaging

为了解决跨域问题,就有了`jsonp`技术,JSONP是一种非正式传输协议,因此本文不提供例子，本质上是利用`<script>`标签不受跨域限制的历史遗留漏洞来实现跨域请求的.该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据.

`jsonp`是一种非正式传输协议,显然不是html5协议会收录的,而官方的解决方案则是使用`web messaging`.

webmessaging主要用在iframe中使用.他可以跨域的不依靠服务器在两个html/js文件间交换数据.当然不跨域也行它主要是跨文档通信

其通信主要依靠

+ 发送:需要一个iframe对象,使用`.contentWindow.postMessage(content, targetOrigin)`方法来发送信息

    `targetOrigin`是目标源，可以限定只接收来自某个域下的数据

+ 使用`window.addEventListener("message", receiveMessage, false);`来接收消息


## WebRTC

webRTC除了控制摄像头麦克风,更关键的特性是支持p2p通信,类`RTCPeerConnection`就是处理p2p连接的类,
`RTCPeerConnection([configuration])`

我们可以创建的时候加入设置,也可以创建后用`.setConfiguration(restartConfig)`方法来设置这个连接,比较重要的是`iceServers`这个参数,用来穿过防火墙

```ts
{
    'iceServers': [{'url': 'stun:23.21.150.121'}]
}

{
    'optional': [{'DtlsSrtpKeyAgreement': true}]
}
```
完成这个配置之后就是为通道创建端点连接了.一根管道当然是有两个端点,所以肯定会要有两个RTCPeerConnection的实例,本机一端叫localConnection,另一机一端叫remoteConnection

连接实例可以有事件绑定

+ onaddstream 连接上添加了流
+ onconnectionstatechange 连接状态改变
+ ondatachannel 当RTCDataChannel由调用createDataChannel（）的远程对等体添加到连接时，会发送类型为RTCDataChannelEvent的此事件。
+ onicecandidate  每当本地ICE代理需要通过信令服务器将消息递送到另一对等体时发生。
+ oniceconnectionstatechange 当由iceConnectionState属性表示的连接的ICE代理的状态发生变化时，会发生这种情况。
+ onicegatheringstatechange 当ICE收集状态（即，ICE代理是否主动收集候选项）时发生这种情况。
+ onidentityresult 当生成身份断言时，通过getIdentityAssertion（）或在提供或回答的创建期间发送此类事件
+ onidpassertionerror 当相关联的身份提供商（IdP）在生成身份断言时遇到错误时，发送这样的事件。
+ onidpvalidationerror 当相关联的身份提供商（IdP）在验证身份断言时遇到错误时，发送这样的事件。
+ onnegotiationneeded 当发生需要进行会话协商的更改时，会触发此事件。
+ onpeeridentity  当从对等体接收到的身份断言已经被成功验证时，发送这样的事件。
+ onremovestream 当从此连接中删除MediaStream时，将发送此类事件。
+ onsignalingstatechange 当RTCPeerConnection.signalingState的值更改时，作为调用setLocalDescription（）或setRemoteDescription（）的结果，将发送此事件。
+ ontrack 当创建了新的传入MediaStreamTrack并与已在连接时添加到该组接收器的RTCRtpReceiver对象相关联时，会发送此事件。



我们要让两端可以通信,除了要建立连接,还要在同一个频道,RTCPeerConnection的实例的`.createDataChannel(channelname[,option])`方法就是用来创建频道,一般都是在本机端创建频道,频道可以有

`.onopen`和`.onclose`两个事件绑定

而另一机一端则是并不需要,但一般要设置`ondatachannel`来确认通道建立成功



接着我们需要两个端点都有有icecandidate,就用刚才的事件绑定`onicecandidate`:

```js
localConnection.onicecandidate = e => !e.candidate
    || remoteConnection.addIceCandidate(e.candidate)
    .catch(handleAddCandidateError)
```
另一端也是一样,IceCandidate需要两边都有

有了连接,有了通道,还要为两端找到标识,这样才能两边建立连通的连接.`RTCSessionDescription`就是这个标识

`localConnection.createOffer()`可以产生一个offer
,也就是一个包含元数据信息的`RTCSessionDescription`的promise,接着我们可以拿这个offer来设置为本机的SessionDescription

`localConnection.setLocalDescription(offer)`


所谓SessionDescription就是一组对连接的唯一表示元数据,包括`RTCSessionDescription.type`和`RTCSessionDescription.sdp`两部分,可以用`.toJSON()`方法获得json数据

每个端点都必须要知道自己的唯一标识和对面的唯一标识,
我们本地的连接有了自己的唯一标识,但还不知道对面的唯一标识,这时候就需要一个服务器来传递这个标识到另一端,而另一端则要先用`.setRemoteDescription(offer)`记录自己对面的标识,之后使用`remoteConnection.createAnswer()`来创建回应的`RTCSessionDescription`,并将之设置为自己的标识`.setLocalDescription(answer)`,然后再把这个answer传回给之前的端点连接

这个用来转发标识的服务器就是所谓的发信服务器了.事实上发信服务器只是一个简单的消息传递,数据传递是p2p的.发信服务器没有限制,只要能发能收就可以了我们完全可以用socketio来实现.当然了,实际上只要能交换就行,因此不通过服务器,而是通过其他比如im呀,邮件呀,人肉呀的方法也是完全可以的.


这样就可以用浏览器实现直播,视频通话之类的功能,这样一些原本只能通过客户端实现的功能了

![webrtc的传输结构](img/webrtc.png)

### 建立连接的顺序

webrtc的连接建立非常看重操作顺序,这个顺序是:
1. 创建端点`RTCPeerConnection`
2. 创建`channel`,这时我们设置的ice服务器就可以触发让我们获得`IceCandidate`的事件
3. 两端通过发信服务器相互交换`IceCandidate`并互设彼此为`IceCandidate`,用`addIceCandidate()`方法
3. 创建offer获取本机`RTCSessionDescription`,并设置为本机的`LocalDescription`,之后通过发信服务器发送给对面
4. 对面接收到本机offer后将之设为`RemoteDescription`,然后在创建`answer`,并设为`LocalDescription`,之后再将`answer`通过发信服务器发送回本机
5. 或得到`answer`后将之设置为本机的`RemoteDescription`

这样就连通好了.

### 发信服务器

我们可以用socketio来建立发信服务器,毕竟它自带room功能.一个发信服务器应该有如下几个接口:

+ `offer`:用来将`offer`传出
+ `answer`: 用来将`answer`传回
+ `candidate`:用来交换`candidate`

其他的就自由发挥了


### 消息传递

消息传递只需要使用DataChannel的send方法即可

### 文件传递

这个例子是传递文件,文件已经有了html5支持,要传输我们只要设置channel的`binaryType = 'arraybuffer'`即可,之后只要把用`reader.readAsArrayBuffer(f)`读出的数据直接发送过去就行了,为了显示,我先将文件信息传了过去,这样就好显示了.

后续还可以加入md5检验,有兴趣的可以自己实现

### 多媒体传递

如果是视屏通讯的话,我们甚至不用借助channel的send方法,只要在各端使用`addStream`添加流,并且各端监听`onaddstream`事件即可

### 复杂多端对等网

基础的p2p只是两端的通信,而如果要多端通信就应该要考虑结构问题了

+ 全连结构

全连结构就是所有节点都相连,在节点不多的情况下还是可以的,但问题在于每个节点的带宽要求都很高,如果带宽小或者链接过多就会效果很不好

+ 星型结构

星型结构是以一个节点作为中心,与所有节点建立联系,而其他各个节点间都没有联系.这种方式可以用来做直播,对中心节点的带宽有很高的要求.

+ 环状结构

环状结构的话每个节点都只有俩个链接,信息在这个圆环中按一个顺序流动,这种方式对带宽要求不高,但一旦有节点要退出,那么处理起来会比较麻烦.而且每个节点必须本地维护一个自身id,这样才能够比较容易的被找到.

+ 使用服务器作为路由

虽然是p2p通信,但为了找到要连接的人往往还是要依靠一个服务器,因此,完全可以在服务器端维护一个各个节点的状态表,由这个服务器来辅助动态的建立连接.

### 无服务器p2p

一个值得注意的demo是<https://github.com/cjb/serverless-webrtc>,这个项目实现了除了需要一个用于找出本机ip的外不再需要服务器,实现真正p2p的效果,相当IMBA.

其实原理很简单,我们从建立连接的顺序可以看出,webrtc通信只是要两端交换`RTCSessionDescription`和`IceCandidate`而已,因此完全可以将这两个信息通过其他途径,比如邮件,比如im来传递即可.

基本的步骤可以是:
1. 将本机的offer和IceCandidate信息以固定格式比如json的形式输出为字符串
2. 将这个输出的字符串发给要连线的人
3. 对方解析这个字符串,将之设置好后获取自己的`answer`和`IceCandidate`,然后再传回给本机
4. 本机解析好对面传来的信息,然后对应的设置好

### 与服务器p2p连接

如果要组星型网络,那么势必需要一台中心节点,一般的机器恐怕无法应付,因此,可能更好的方法是让服务器来作为中心节点,node上可用的webrtc<https://github.com/js-platform/node-webrtc>可以在github上找到,但版本比较低,可能需要编译安装.


使用它的话就可以在服务器上运行一个进程直接交互了
